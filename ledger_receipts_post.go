package procountor

import (
	"net/http"
	"net/url"
	"time"

	"github.com/omniboost/go-procountor/utils"
)

func (c *Client) NewLedgerReceiptsPostRequest() LedgerReceiptsPostRequest {
	r := LedgerReceiptsPostRequest{
		client:  c,
		method:  http.MethodPost,
		headers: http.Header{},
	}

	r.queryParams = r.NewQueryParams()
	r.pathParams = r.NewPathParams()
	r.requestBody = r.NewRequestBody()
	return r
}

type LedgerReceiptsPostRequest struct {
	client      *Client
	queryParams *LedgerReceiptsPostRequestQueryParams
	pathParams  *LedgerReceiptsPostRequestPathParams
	method      string
	headers     http.Header
	requestBody LedgerReceiptsPostRequestBody
}

func (r LedgerReceiptsPostRequest) NewQueryParams() *LedgerReceiptsPostRequestQueryParams {
	return &LedgerReceiptsPostRequestQueryParams{}
}

type LedgerReceiptsPostRequestQueryParams struct{}

func (p LedgerReceiptsPostRequestQueryParams) ToURLValues() (url.Values, error) {
	encoder := utils.NewSchemaEncoder()
	encoder.RegisterEncoder(Date{}, utils.EncodeSchemaMarshaler)
	encoder.RegisterEncoder(DateTime{}, utils.EncodeSchemaMarshaler)
	params := url.Values{}

	err := encoder.Encode(p, params)
	if err != nil {
		return params, err
	}

	return params, nil
}

func (r *LedgerReceiptsPostRequest) QueryParams() *LedgerReceiptsPostRequestQueryParams {
	return r.queryParams
}

func (r LedgerReceiptsPostRequest) NewPathParams() *LedgerReceiptsPostRequestPathParams {
	return &LedgerReceiptsPostRequestPathParams{}
}

type LedgerReceiptsPostRequestPathParams struct {
}

func (p *LedgerReceiptsPostRequestPathParams) Params() map[string]string {
	return map[string]string{}
}

func (r *LedgerReceiptsPostRequest) PathParams() *LedgerReceiptsPostRequestPathParams {
	return r.pathParams
}

func (r *LedgerReceiptsPostRequest) PathParamsInterface() PathParams {
	return r.pathParams
}

func (r *LedgerReceiptsPostRequest) SetMethod(method string) {
	r.method = method
}

func (r *LedgerReceiptsPostRequest) Method() string {
	return r.method
}

func (r LedgerReceiptsPostRequest) NewRequestBody() LedgerReceiptsPostRequestBody {
	return LedgerReceiptsPostRequestBody{}
}

type LedgerReceiptsPostRequestBody struct {
	// readOnly: true
	// Unique identifier of the ledger receipt. Generated by Procountor and
	// present in the object returned.
	ID int `json:"id,omitempty"`
	// Ledger receipt type. Use JOURNAL for creating ledger receipts (vouchers)
	// containing ledger transactions without linkage to pre-existing resources.
	// Other types are automatically generated by Procountor for holding
	// accounting information for e.g. invoices. Types allowed for POST =
	// JOURNAL. Types allowed for PUT = JOURNAL, SALES_INVOICE,
	// PURCHASE_INVOICE, TRAVEL_INVOICE, BILL_OF_CHARGES Types allowed for GET
	// listed below:
	// [ JOURNAL, PURCHASE_INVOICE, SALES_INVOICE, PERIODIC_TAX_RETURN,
	// TRAVEL_INVOICE, BILL_OF_CHARGES, VAT_FORM, SALARY, EMPLOYER_CONTRIBUTION,
	// PURCHASE_ORDER, SALES_ORDER, BANK_STATEMENT_AS_RECEIPT,
	// RECEIPT_FOR_OPENING_ACCOUNTS, REFERENCE_PAYMENT,
	// TRACKING_PERIOD_OPENING_RECEIPT, VAT_SUMMARY ]
	Type string `json:"type"`
	// readOnly: true
	// Ledger receipt status. Status of a ledger receipt equals the status of
	// the linked invoice. All ledger receipts are initially created with status
	// UNFINISHED. For journals, possible statuses are UNFINISHED, APPROVED and
	// INVALIDATED. Ledger receipt statuses cannot be directly modified through
	// the API.
	Status string `json:"status,omitempty"`
	// Ledger receipt name.
	Name string `json:"name"`
	// Ledger receipt date. Must not be in a closed fiscal period. See GET
	// /fiscalyears for a list of fiscal years.
	ReceiptDate string `json:"receiptDate"`
	// Ledger receipt VAT type.
	// [ SALES, PURCHASE ]
	// Ledger receipt VAT status. This can be overridden on transaction level.
	// Use here the numeric parts of VAT status codes listed in "VAT defaults"
	// in Procountor. For example, for VAT status code "vat_12", use value 12.
	// The VAT status used must be enabled for the current receipt type
	// (sales/purchase).
	VatType   string `json:"vatType"`
	VatStatus int    `json:"vatStatus"`
	// Ledger receipt VAT country. Only for JOURNAL types of ledger receipts.
	// Requires a special right for foreign VATs. See Address.country in POST
	// /invoices for a list of allowable values.
	VatProcessing string `json:"vatProcessing,omitempty"`
	// readOnly: true
	// ID of the linked invoice. For sales and purchase invoice ledger receipts,
	// this refers to the invoice the receipt holds accounting data for. For
	// journal receipts, an invoice is automatically generated to store certain
	// data fields. Use this ID in POST /attachments endpoint.
	InvoiceID int `json:"invoiceId,omitempty"`
	// readOnly: true
	// Receipt number of bank statement as receipt.
	ReceiptNumber int `json:"receiptNumber,omitempty"`
	// Invoice notes. Linked to Invoice.notes. Not visible on ledger receipt
	// printouts. Use \n as line break. Max length 10000.
	InvoiceNotes string `json:"invoiceNotes"`
	// readOnly: true
	// Number of the linked invoice. Automatically generated by Procountor.
	InvoiceNumber int `json:"invoiceNumber,omitempty"`
	// Notes made by the accountant. Visible on ledger receipt printouts.
	AccountantsNotes string `json:"accountantsNotes"`
	// Transaction description. This is a summary description for any
	// transactions belonging to the ledger receipt.
	TransactionDescription string `json:"transactionDescription"`
	// Receipt validity time.
	// [ EMPTY, IMMEDIATELY, SERVICE_PERIOD, OVER_3_YEARS ]
	ReceiptValidity string `json:"receiptValidity,omitempty"`
	// Start date of the receipt period. If set, must precede the end date of
	// the period.
	PeriodStartDate string `json:"periodStartDate"`
	// End date of the receipt period. If this and the start date are set, this
	// must be after the start date.
	PeriodEndDate string `json:"periodEndDate"`
	// Partner code. Identifier for the related company or person. May represent
	// a business ID, national identification number (HETU in Finland) or an
	// account number, depending on the receipt type.
	PartnerCode string `json:"partnerCode,omitempty"`
	// Ledger receipt version timestamp. Automatically generated by Procountor
	// and updated every time the receipt is modified. When using PUT
	// /ledgerreceipts, it is required to include the latest version timestamp
	// of the receipt to the request. This prevents conflicts if the receipt is
	// being modified from several sources.
	Version time.Time `json:"version,omitempty"`
	// Accounting depreciation method for the receipt.
	Depreciation string `json:"depreciation,omitempty"`
	// VAT date to be used if payment based VAT is enabled
	VatDate      string `json:"vatDate,omitempty"`
	Transactions []struct {
		// readOnly: true
		// Unique identifier for the ledger transaction. Automatically generated
		// by Procountor and present in the object returned.
		ID int `json:"id,omitempty"`
		// Transaction type. Depends on the transaction and the ledger account
		// in question. Type REVERSING_ENTRY is used to indicate the first row
		// of a ledger receipt for a specific logic on the UI. Typically, it
		// represents a transaction for a balance sheet account. Note that
		// ledger receipts with no transactions marked as reversing entries are
		// possible. Type ENTRY is the general type for transactions. It can be
		// used even on the first rows of ledger receipts. Type
		// RECONCILIATION_ENTRY is used for getting the sum of transactions on a
		// receipt to reconcile (to equal zero). Generally, all ledger receipts
		// should reconcile. Procountor can create reconciliation entries
		// automatically for ledger receipts when "createReconciliation=true"
		// query parameter is specified. If VAT is used, a reconciliation row
		// might be necessary due to remainders and rounding. For both
		// REVERSING_ENTRY and RECONCILIATION_ENTRY transactions, vatStatus
		// cannot be defined and vatPercent must be 0. Additionally, a ledger
		// can have maximum of one REVERSING_ENTRY and maximum of one
		// RECONCILIATION_ENTRY transaction. Transactions of these types cannot
		// be removed from a ledger receipt using UI once created.
		// [ RECONCILIATION_ENTRY, REVERSING_ENTRY, ENTRY ]
		TransactionType string `json:"transactionType"`
		// Ledger account number for the transaction. Must be valid for the
		// current Procountor environment. Use GET /coa to obtain the chart of
		// accounts.
		Account string `json:"account"`
		// Transaction accounting value. This value is net. Scale: 2.
		AccountingValue float64 `json:"accountingValue"`
		// Transaction VAT percentage. Must be a percentage currently in use for
		// the company.
		VatPercent float64 `json:"vatPercent"`
		// Transaction VAT type.
		// [ SALES, PURCHASE ]
		VatType string `json:"vatType"`
		// Transaction VAT status. This overrides the VAT status set for the
		// parent ledger receipt. Use here the numeric parts of VAT status codes
		// listed in "VAT defaults" in Procountor. For example, for VAT status
		// code "vat_12", use value 12. The VAT status used must be enabled for
		// the current receipt type (sales/purchase).
		VatStatus int `json:"vatStatus"`
		// Transaction description. Visible on ledger receipt printouts.
		Description string `json:"description"`
		// Transaction balance code. Only available if the use balance sheet
		// setting is enabled.
		BalanceCode string `json:"balanceCode,omitempty"`
		// Technical ID for the partner. Can be provided in Norwegian
		// environments only. The given partner id must match a partner of type
		// different than PERSON, existing in the current Procountor
		// environment.
		PartnerID int `json:"partnerId,omitempty"`
		// Values of dimension items associated with this transaction. The
		// number of provided dimension items must be within the dimension max
		// count defined by the purchased Procountor license. Provided dimension
		// pairs (dimension id - item id) must be unique within the list
		// provided.
		DimensionItemValues []struct {
			// Dimension ID. Must exist in the current environment. For a list
			// of available dimensions, see the GET /dimensions endpoint.
			DimensionID int `json:"dimensionId"`
			// Dimension item ID. Must exist in the current environment. For a
			// list of available dimensions, see the GET /dimensions endpoint.
			ItemID int `json:"itemId"`
			// Dimension item value with maximum two decimal places. Use
			// absolute values instead of percentages. The sum of dimension item
			// values on a dimension must equal the accounting value of the
			// parent transaction.
			Value int `json:"value"`
		} `json:"dimensionItemValues"`
		// VAT deduction percentage for the transaction.
		VatDeductionPercent int `json:"vatDeductionPercent,omitempty"`
		// Start date of accrual/delivery periods of transaction.
		StartDate string `json:"startDate,omitempty"`
		// End date of accrual/delivery periods of transaction.
		EndDate string `json:"endDate,omitempty"`
	} `json:"transactions"`
}

func (r *LedgerReceiptsPostRequest) RequestBody() *LedgerReceiptsPostRequestBody {
	return &r.requestBody
}

func (r *LedgerReceiptsPostRequest) RequestBodyInterface() interface{} {
	return &r.requestBody
}

func (r *LedgerReceiptsPostRequest) SetRequestBody(body LedgerReceiptsPostRequestBody) {
	r.requestBody = body
}

func (r *LedgerReceiptsPostRequest) NewResponseBody() *LedgerReceiptsPostResponseBody {
	return &LedgerReceiptsPostResponseBody{}
}

type LedgerReceiptsPostResponseBody Dimensions

func (r *LedgerReceiptsPostRequest) URL() *url.URL {
	u := r.client.GetEndpointURL("/ledgerreceipts", r.PathParams())
	return &u
}

func (r *LedgerReceiptsPostRequest) Do() (LedgerReceiptsPostResponseBody, error) {
	// Create http request
	req, err := r.client.NewRequest(nil, r)
	if err != nil {
		return *r.NewResponseBody(), err
	}

	// Process query parameters
	err = utils.AddQueryParamsToRequest(r.QueryParams(), req, false)
	if err != nil {
		return *r.NewResponseBody(), err
	}

	responseBody := r.NewResponseBody()
	_, err = r.client.Do(req, responseBody)
	return *responseBody, err
}
